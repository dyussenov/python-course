# makefile

## Что такое make и makefile?

`make` - утилита, автоматизирующая рутинные действия в терминале. Изначально создавалась для упрощения сборки проектов на C++, но затем перекочевала в остальные отрасли (тут будут примеры для питона). make работает в UNIX-подобных системах, но также существуют аналоги для Windows.

`makefile` - текстовый файл, содержащий список команд для make. Использует собственный синтаксис, легкий в понимании и простой в изучении.

---

Допустим, вы вместе с командой разработчиков пишете проект на python. В команде принято перед пушем коммита в репозиторий пройти линтер и запустить тесты. Посмотрим, сколько нужно выполнить команд:

- Прогнать форматтеры: `python3 -m isort` и `python3 -m black`
- Прогнать линтер: `python3 -m pylint`
- Поднять базу для тестов: `docker-compose -f docker-compose.yml up -d --remove-orphans`
- Запустить миграции для тестовой базы: `alembic upgrade head`
- Запустить тесты: `python3 -m pytest`

Используя make вышеперечисленные команды можно сократить до такого вида:

```shell
$ make format
$ make lint
$ make test
```

## Из чего состоит makefile

Синтаксис простого make правила:

```makefile
цель (target): зависимости (dependencies)
    команды для командной строки
```

### Цель

**Цель (target)** - такое название эта часть правила получила потому что изначально тут указывалось имя файла, который должен быть сгенерирован в результате вызова этого правила (вспоминмаем, что изначально make был создан для упрощения сборки проектов на C++). Однако, не всегда требуется создание какого-то файла, поэтому допускается в качестве цели указывать название задачи, которую выполняет правило. Например: цель `format` для запуска форматтеров `python3 -m isort && python3 -m black`.

---

В качестве примера, создадим файл с названием `Makefile` и пропишем в нем простейшее правило:

```makefile
hello:
	echo "hello world!"
```

Попробуем вызвать наше правило. При вызове утилиты make она будет искать файл с названием `Makefile` и искать необходимое правило в нем:

```shell
$ make hello
```

Получаем такой результат:

```shell
echo "hello world!"
hello world!
```

Как можно заметить, make передал команду `echo "hello world!"` из правила в терминал, где она была выполнена.

---

### Переменные

Теперь можно попробовать добавить *переменные* в makefile. Пример создания и использования переменной:

```makefile
PYTHON = python3
VENV_DIR = venv

venv: # правило для создания виртуального окружения
	$(PYTHON) -m venv $(VENV_DIR)
```

Теперь, при вызове `make venv` будет выполнена команда `python3 -m venv venv`. Также прошу обратить внимаение, что в примере продемонстрировано использование комментариев.

---

### Зависимости

А теперь разберемся с *зависимостями*. В зависимостях указываются цели которые должны быть выполнены или файлы которе должны присутствовать в директории. Разберем на примере:

```makefile
PYTHON = python3

run: main.py
	$(PYTHON) -m main
```

Здесь при попытке вызвать `make run` без файла main.py в директории мы получим ошибку от make:

```shell
make: *** No rule to make target 'main.py', needed by 'run'.  Stop.
```

Из текста сообщения понятно, что утилита make попыталась найти цель `main.py`, которая необходима для цели `run`. Чтобы двигаться дальше у нас есть два пути:

- Вручную создать файл `main.py`. Тогда утилита make обнаружит цель main.py, что в свою очередь удовлетворит зависимости цели `run`.

- Указать правило для цели main.py. В данной конфигурации цель будет срабатывать даже если в директории изначально отсутствовал файл зависимости:
    
    ```makefile
    PYTHON = python3

    run: main.py
        $(PYTHON) -m main


    main.py: clean
        echo 'print("hello world")' >> main.py

    clean:
        rm -rf __pycache__ && rm -f main.py
    ```

---

Зависимости позволяют удобно управлять последовательностью выполнения целей, что может быть крайне полезно. Например, в процессе разработки вам необходим запущенный контейнер с базой данных, поэтому создадим цель для запуска контейнера:

```makefile
db:
	docker-compose -f docker-compose.yml up -d --remove-orphans
```

А теперь допустим, что вам для unit-тестирования тоже необходима база данных, но не факт что на момент запуска тестов есть контейнер с базой. Тут нам и пригождаются зависимости:

```makefile
db:
	docker-compose -f docker-compose.yml up -d --remove-orphans

migrate:
	alembic upgrade head

test: db migrate
	python3 -m pytest --verbosity=2 --showlocals --log-level=DEBUG
```

В данном примере перед запуском тестов будет поднят контейнер с базой и произведены актуальные миграции.

## Условия в makefile

Условия в make позволяют сделать выполнение целей более гибким. Для создания условий у нас есть несколько операторов: `ifeq`, `ifneq`, `ifdef` и `ifndef`. У каждого оператора можно указать `else`, а также каждый оператор должен быть закрыт при помощи `endif`.

### ifeq (если равно), ifneq (если не равно)

```makefile
ifeq ($(shell test -e '.env' && echo -n yes),yes)
	include .env
endif
```

### ifdef (если определено), ifndef (если не определено)

В данном примере если не установить хост и порт, то будут использоваться значения по умолчанию:

```makefile
ifndef APP_PORT
APP_PORT = 8000
endif

ifndef APP_HOST
APP_HOST = 127.0.0.1
endif

run: # Запустить веб-сервер
    uvicorn main:app --host APP_HOST --port APP_PORT
```
